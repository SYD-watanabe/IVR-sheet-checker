<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IVRè¨­å®šã‚·ãƒ¼ãƒˆ èª¤å­—è„±å­—ãƒã‚§ãƒƒã‚«ãƒ¼</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
        .loading-spinner {
            border: 3px solid #f3f3f3;
            border-top: 3px solid #3b82f6;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        .excel-preview {
            border: 1px solid #e5e7eb;
            background: white;
            overflow: auto;
            max-height: 500px;
        }
        .shape-highlight {
            border: 2px solid #ef4444;
            background: rgba(239, 68, 68, 0.1);
            padding: 8px;
            margin: 4px 0;
            border-radius: 4px;
        }
    </style>
</head>
<body class="bg-gray-50 min-h-screen">
    <div class="container mx-auto px-4 py-8 max-w-6xl">
        <!-- Header -->
        <div class="bg-white rounded-lg shadow-md p-6 mb-6">
            <h1 class="text-3xl font-bold text-gray-800 mb-2">IVRè¨­å®šã‚·ãƒ¼ãƒˆ èª¤å­—è„±å­—ãƒã‚§ãƒƒã‚«ãƒ¼</h1>
            <p class="text-gray-600">Excelãƒ•ã‚¡ã‚¤ãƒ«å†…ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆï¼ˆå›³å½¢ãƒ»ãƒ†ã‚­ã‚¹ãƒˆãƒœãƒƒã‚¯ã‚¹ï¼‰ã®ãƒ†ã‚­ã‚¹ãƒˆã‚’AIã§è§£æã—ã¾ã™</p>
        </div>

        <!-- API Key Section -->
        <div class="bg-white rounded-lg shadow-md p-6 mb-6">
            <h2 class="text-xl font-semibold text-gray-800 mb-4">Gemini APIã‚­ãƒ¼è¨­å®š</h2>
            <div class="flex gap-4">
                <input 
                    type="password" 
                    id="apiKey" 
                    placeholder="Gemini APIã‚­ãƒ¼ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„"
                    class="flex-1 px-4 py-2 border border-gray-300 rounded-lg focus:ring-2 focus:ring-blue-500 focus:border-transparent"
                >
                <button 
                    onclick="saveApiKey()"
                    class="bg-blue-500 hover:bg-blue-600 text-white px-6 py-2 rounded-lg font-medium transition"
                >
                    ä¿å­˜
                </button>
            </div>
            <p class="text-sm text-gray-500 mt-2">
                APIã‚­ãƒ¼ã¯ <a href="https://aistudio.google.com/app/apikey" target="_blank" class="text-blue-500 underline">Google AI Studio</a> ã§å–å¾—ã§ãã¾ã™
            </p>
            <div id="apiKeyStatus" class="mt-2"></div>
        </div>

        <!-- Upload Section -->
        <div class="bg-white rounded-lg shadow-md p-6 mb-6">
            <h2 class="text-xl font-semibold text-gray-800 mb-4">Excelãƒ•ã‚¡ã‚¤ãƒ«ã‚¢ãƒƒãƒ—ãƒ­ãƒ¼ãƒ‰</h2>
            
            <!-- Instructions -->
            <div class="bg-blue-50 border border-blue-200 rounded-lg p-4 mb-4">
                <h3 class="font-semibold text-blue-900 mb-2">ğŸ“ å¯¾å¿œãƒ•ã‚¡ã‚¤ãƒ«å½¢å¼</h3>
                <ul class="text-sm text-blue-800 space-y-1 ml-4">
                    <li>âœ… .xlsxï¼ˆExcel 2007ä»¥é™ï¼‰</li>
                    <li>âœ… .xlsmï¼ˆãƒã‚¯ãƒ­æœ‰åŠ¹ãƒ¯ãƒ¼ã‚¯ãƒ–ãƒƒã‚¯ï¼‰</li>
                    <li>âœ… ãƒ•ã‚¡ã‚¤ãƒ«å†…ã®å›³å½¢ãƒ»ãƒ†ã‚­ã‚¹ãƒˆãƒœãƒƒã‚¯ã‚¹ã®ãƒ†ã‚­ã‚¹ãƒˆã‚’æŠ½å‡º</li>
                    <li>âŒ ã‚»ãƒ«å†…ã®ãƒ†ã‚­ã‚¹ãƒˆã¯å¯¾è±¡å¤–</li>
                </ul>
                
                <h3 class="font-semibold text-blue-900 mb-2 mt-3">â­ï¸ é™¤å¤–è¨­å®š</h3>
                <div class="text-sm text-blue-800 space-y-1 ml-4">
                    <p><strong>é™¤å¤–ã‚·ãƒ¼ãƒˆ:</strong> ç·¨é›†ä¾‹</p>
                    <p><strong>é™¤å¤–ãƒ†ã‚­ã‚¹ãƒˆ:</strong> â¡æŒ¯ã‚Šåˆ†ã‘ãƒ«ãƒ¼ãƒ«ã€ğŸ“è»¢é€ã€ğŸ“ç•™å®ˆé›»ã€âœ‰SMSé€ä¿¡å†…å®¹ã€âœ‰ãƒ¡ãƒ¼ãƒ«é€šçŸ¥ã€â™ªéŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«</p>
                </div>
            </div>
            
            <div id="dropZone" class="border-2 border-dashed border-gray-300 rounded-lg p-8 text-center hover:border-blue-400 transition cursor-pointer">
                <input 
                    type="file" 
                    id="excelFile" 
                    accept=".xlsx,.xlsm"
                    class="hidden"
                >
                <label for="excelFile" class="cursor-pointer block">
                    <svg class="mx-auto h-12 w-12 text-gray-400" stroke="currentColor" fill="none" viewBox="0 0 48 48">
                        <path d="M28 8H12a4 4 0 00-4 4v20m32-12v8m0 0v8a4 4 0 01-4 4H12a4 4 0 01-4-4v-4m32-4l-3.172-3.172a4 4 0 00-5.656 0L28 28M8 32l9.172-9.172a4 4 0 015.656 0L28 28m0 0l4 4m4-24h8m-4-4v8m-12 4h.02" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" />
                    </svg>
                    <p class="mt-2 text-sm text-gray-600">
                        <span class="font-medium text-blue-500">ã‚¯ãƒªãƒƒã‚¯ã—ã¦ãƒ•ã‚¡ã‚¤ãƒ«ã‚’é¸æŠ</span> ã¾ãŸã¯ ãƒ‰ãƒ©ãƒƒã‚°ï¼†ãƒ‰ãƒ­ãƒƒãƒ—
                    </p>
                    <p class="text-xs text-gray-500 mt-1">Excelå½¢å¼ (.xlsx, .xlsm) ã®ã¿å¯¾å¿œ</p>
                </label>
            </div>
            <div id="fileInfo" class="mt-4"></div>
        </div>

        <!-- Loading Section -->
        <div id="loadingSection" class="hidden bg-white rounded-lg shadow-md p-8 mb-6">
            <div class="flex flex-col items-center">
                <div class="loading-spinner"></div>
                <p class="mt-4 text-gray-600" id="loadingMessage">å‡¦ç†ä¸­...</p>
            </div>
        </div>

        <!-- Results Section -->
        <div id="resultsSection" class="hidden">
            <!-- Excel Preview -->
            <div class="bg-white rounded-lg shadow-md p-6 mb-6">
                <h2 class="text-xl font-semibold text-gray-800 mb-4">æŠ½å‡ºã•ã‚ŒãŸãƒ†ã‚­ã‚¹ãƒˆ</h2>
                <div id="extractedTexts" class="space-y-4"></div>
            </div>

            <!-- Errors Found -->
            <div class="bg-white rounded-lg shadow-md p-6 mb-6">
                <h2 class="text-xl font-semibold text-gray-800 mb-4">èª¤å­—è„±å­—ãƒã‚§ãƒƒã‚¯çµæœ</h2>
                <div id="errorResults"></div>
            </div>
        </div>
    </div>

    <script>
    // Global variables
    let workbook = null;
    let apiKey = localStorage.getItem('gemini_api_key') || '';
    let extractedShapes = [];
    
    // ãƒãƒƒãƒå‡¦ç†ã®è¨­å®š
    const BATCH_SIZE = 10; // 1å›ã®ãƒªã‚¯ã‚¨ã‚¹ãƒˆã§å‡¦ç†ã™ã‚‹ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆæ•°ï¼ˆ5â†’10ã«å¢—é‡ï¼‰
    
    // é™¤å¤–ã™ã‚‹ã‚·ãƒ¼ãƒˆå
    const EXCLUDED_SHEETS = ['ç·¨é›†ä¾‹'];
    
    // é™¤å¤–ã™ã‚‹ãƒ†ã‚­ã‚¹ãƒˆãƒ‘ã‚¿ãƒ¼ãƒ³
    const EXCLUDED_TEXT_PATTERNS = [
        'â¡æŒ¯ã‚Šåˆ†ã‘ãƒ«ãƒ¼ãƒ«',
        'â¡æŒ¯ã‚Šåˆ†ã‘ãƒ«ãƒ¼ãƒ«',
        'ğŸ“è»¢é€',
        'ğŸ“ç•™å®ˆé›»',
        'âœ‰SMSé€ä¿¡å†…å®¹',
        'âœ‰ãƒ¡ãƒ¼ãƒ«é€šçŸ¥',
        'â™ªéŸ³å£°ãƒ•ã‚¡ã‚¤ãƒ«'
    ];

    // Initialize API key display
    document.addEventListener('DOMContentLoaded', () => {
        console.log('DOM Content Loaded');
        
        // Initialize API key
        if (apiKey) {
            document.getElementById('apiKey').value = apiKey;
            showApiKeyStatus('APIã‚­ãƒ¼ãŒä¿å­˜ã•ã‚Œã¦ã„ã¾ã™', 'success');
        }
        
        // Setup file input handler
        const fileInput = document.getElementById('excelFile');
        if (fileInput) {
            console.log('Setting up file input handler');
            fileInput.addEventListener('change', handleFileUpload);
        } else {
            console.error('File input element not found!');
        }
        
        // Setup drag and drop
        const dropZone = document.getElementById('dropZone');
        if (dropZone) {
            console.log('Setting up drag and drop handlers');
            
            dropZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                e.stopPropagation();
                dropZone.classList.add('border-blue-500', 'bg-blue-50');
            });
            
            dropZone.addEventListener('dragleave', (e) => {
                e.preventDefault();
                e.stopPropagation();
                dropZone.classList.remove('border-blue-500', 'bg-blue-50');
            });
            
            dropZone.addEventListener('drop', (e) => {
                e.preventDefault();
                e.stopPropagation();
                dropZone.classList.remove('border-blue-500', 'bg-blue-50');
                
                const files = e.dataTransfer.files;
                if (files.length > 0) {
                    fileInput.files = files;
                    const event = new Event('change', { bubbles: true });
                    fileInput.dispatchEvent(event);
                }
            });
        }
    });

    // Save API Key
    function saveApiKey() {
        const input = document.getElementById('apiKey');
        apiKey = input.value.trim();
        
        if (!apiKey) {
            showApiKeyStatus('APIã‚­ãƒ¼ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„', 'error');
            return;
        }
        
        localStorage.setItem('gemini_api_key', apiKey);
        showApiKeyStatus('APIã‚­ãƒ¼ã‚’ä¿å­˜ã—ã¾ã—ãŸ', 'success');
    }

    window.saveApiKey = saveApiKey;

    function showApiKeyStatus(message, type) {
        const statusDiv = document.getElementById('apiKeyStatus');
        const colorClass = type === 'success' ? 'text-green-600' : 'text-red-600';
        statusDiv.innerHTML = `<p class="text-sm ${colorClass}">${message}</p>`;
        
        setTimeout(() => {
            statusDiv.innerHTML = '';
        }, 3000);
    }

    // Handle file upload
    async function handleFileUpload(event) {
        console.log('File upload handler called');
        const file = event.target.files[0];
        if (!file) {
            console.log('No file selected');
            return;
        }
        
        console.log('File selected:', file.name, file.size, 'bytes');
        
        if (!apiKey) {
            alert('å…ˆã«Gemini APIã‚­ãƒ¼ã‚’è¨­å®šã—ã¦ãã ã•ã„');
            event.target.value = '';
            return;
        }
        
        const fileInfoDiv = document.getElementById('fileInfo');
        fileInfoDiv.innerHTML = `
            <div class="flex items-center gap-2 text-sm text-gray-600">
                <svg class="h-5 w-5 text-green-500" fill="currentColor" viewBox="0 0 20 20">
                    <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"/>
                </svg>
                <span><strong>${file.name}</strong> (${(file.size / 1024).toFixed(2)} KB)</span>
            </div>
        `;
        
        showLoading('Excelãƒ•ã‚¡ã‚¤ãƒ«ã‚’èª­ã¿è¾¼ã‚“ã§ã„ã¾ã™...');
        
        try {
            console.log('Reading file as ArrayBuffer...');
            const data = await readFileAsArrayBuffer(file);
            console.log('File read successfully, size:', data.byteLength);
            
            console.log('Parsing Excel file...');
            workbook = XLSX.read(data, { 
                type: 'array',
                cellStyles: true,
                bookVBA: true
            });
            console.log('Excel parsed, sheets:', workbook.SheetNames);
            
            updateLoadingMessage('ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹ã‚‰ãƒ†ã‚­ã‚¹ãƒˆã‚’æŠ½å‡ºã—ã¦ã„ã¾ã™...');
            console.log('Extracting shapes...');
            extractedShapes = await extractShapeTexts(workbook, data);
            console.log('Extracted shapes:', extractedShapes.length);
            
            if (extractedShapes.length === 0) {
                hideLoading();
                alert('ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆï¼ˆå›³å½¢ãƒ»ãƒ†ã‚­ã‚¹ãƒˆãƒœãƒƒã‚¯ã‚¹ï¼‰å†…ã®ãƒ†ã‚­ã‚¹ãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚\n\nExcelãƒ•ã‚¡ã‚¤ãƒ«ã«å›³å½¢ã‚„ãƒ†ã‚­ã‚¹ãƒˆãƒœãƒƒã‚¯ã‚¹ãŒå«ã¾ã‚Œã¦ã„ã‚‹ã‹ç¢ºèªã—ã¦ãã ã•ã„ã€‚');
                event.target.value = '';
                return;
            }
            
            console.log('Displaying extracted texts...');
            displayExtractedTexts(extractedShapes);
            
            updateLoadingMessage('AIè§£æä¸­ï¼ˆèª¤å­—è„±å­—ã‚’ãƒã‚§ãƒƒã‚¯ã—ã¦ã„ã¾ã™ï¼‰...');
            console.log('Starting Gemini analysis...');
            await checkTextWithGemini(extractedShapes);
            
            console.log('Processing complete');
            hideLoading();
            
        } catch (error) {
            console.error('Error processing file:', error);
            hideLoading();
            alert('ãƒ•ã‚¡ã‚¤ãƒ«ã®å‡¦ç†ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ: ' + error.message);
            event.target.value = '';
        }
    }

    function readFileAsArrayBuffer(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = (e) => resolve(e.target.result);
            reader.onerror = (e) => reject(e);
            reader.readAsArrayBuffer(file);
        });
    }

    async function extractShapeTexts(workbook, fileData) {
        const shapes = [];
        
        try {
            console.log('Loading JSZip...');
            const JSZip = await loadJSZip();
            console.log('JSZip loaded, parsing file as ZIP...');
            const zip = await JSZip.loadAsync(fileData);
            console.log('ZIP parsed successfully');
            
            const promises = [];
            
            for (let sheetIndex = 0; sheetIndex < workbook.SheetNames.length; sheetIndex++) {
                const sheetName = workbook.SheetNames[sheetIndex];
                
                // é™¤å¤–ã‚·ãƒ¼ãƒˆã®ãƒã‚§ãƒƒã‚¯
                if (EXCLUDED_SHEETS.includes(sheetName)) {
                    console.log(`â­ï¸ Skipping excluded sheet: ${sheetName}`);
                    continue;
                }
                
                console.log(`Processing sheet ${sheetIndex + 1}: ${sheetName}`);
                
                const drawingPath = `xl/drawings/drawing${sheetIndex + 1}.xml`;
                const vmlDrawingPath = `xl/drawings/vmlDrawing${sheetIndex + 1}.vml`;
                
                const drawingFile = zip.file(drawingPath);
                if (drawingFile) {
                    console.log(`  Found drawing file: ${drawingPath}`);
                    const promise = drawingFile.async('string').then(xmlContent => {
                        const texts = extractTextsFromDrawingXML(xmlContent, sheetName);
                        console.log(`  Extracted ${texts.length} texts from drawing XML`);
                        shapes.push(...texts);
                    }).catch(err => console.error('Drawing parsing error:', err));
                    promises.push(promise);
                } else {
                    console.log(`  No drawing file found: ${drawingPath}`);
                }
                
                const vmlFile = zip.file(vmlDrawingPath);
                if (vmlFile) {
                    console.log(`  Found VML file: ${vmlDrawingPath}`);
                    const promise = vmlFile.async('string').then(vmlContent => {
                        const texts = extractTextsFromVML(vmlContent, sheetName);
                        console.log(`  Extracted ${texts.length} texts from VML`);
                        shapes.push(...texts);
                    }).catch(err => console.error('VML parsing error:', err));
                    promises.push(promise);
                } else {
                    console.log(`  No VML file found: ${vmlDrawingPath}`);
                }
            }
            
            console.log(`Waiting for ${promises.length} async operations...`);
            await Promise.all(promises);
            console.log(`All operations complete. Total shapes extracted: ${shapes.length}`);
            
        } catch (error) {
            console.error('Error extracting shapes:', error);
        }
        
        return shapes;
    }

    function loadJSZip() {
        return new Promise((resolve, reject) => {
            if (window.JSZip) {
                resolve(window.JSZip);
                return;
            }
            
            const script = document.createElement('script');
            script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js';
            script.onload = () => resolve(window.JSZip);
            script.onerror = reject;
            document.head.appendChild(script);
        });
    }

    function extractTextsFromDrawingXML(xmlContent, sheetName) {
        const texts = [];
        const parser = new DOMParser();
        const xmlDoc = parser.parseFromString(xmlContent, 'text/xml');
        
        const textElements = xmlDoc.getElementsByTagName('a:t');
        
        for (let i = 0; i < textElements.length; i++) {
            const text = textElements[i].textContent.trim();
            if (text && shouldIncludeShape(sheetName, text)) {
                texts.push({
                    sheet: sheetName,
                    type: 'shape',
                    text: text,
                    location: `ã‚·ãƒ¼ãƒˆ: ${sheetName}, ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ #${texts.length + 1}`
                });
            }
        }
        
        return texts;
    }

    function extractTextsFromVML(vmlContent, sheetName) {
        const texts = [];
        const textMatches = vmlContent.matchAll(/<div[^>]*>(.*?)<\/div>/gs);
        
        for (const match of textMatches) {
            const text = match[1].replace(/<[^>]*>/g, '').trim();
            if (text && shouldIncludeShape(sheetName, text)) {
                texts.push({
                    sheet: sheetName,
                    type: 'vml',
                    text: text,
                    location: `ã‚·ãƒ¼ãƒˆ: ${sheetName}, VMLã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ #${texts.length + 1}`
                });
            }
        }
        
        return texts;
    }

    function displayExtractedTexts(shapes) {
        const container = document.getElementById('extractedTexts');
        
        if (shapes.length === 0) {
            container.innerHTML = '<p class="text-gray-500">ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆå†…ã®ãƒ†ã‚­ã‚¹ãƒˆãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ</p>';
            return;
        }
        
        // ã‚³ãƒ³ãƒ‘ã‚¯ãƒˆè¡¨ç¤º
        const batchCount = Math.ceil(shapes.length / BATCH_SIZE);
        let html = `
            <div class="bg-blue-50 border border-blue-200 rounded-lg p-3 mb-3">
                <p class="text-sm text-blue-800">âœ… <strong>${shapes.length}å€‹</strong>ã®ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã‹ã‚‰ãƒ†ã‚­ã‚¹ãƒˆã‚’æŠ½å‡ºã—ã¾ã—ãŸ</p>
                <p class="text-xs text-blue-600 mt-1">ğŸ’¡ ãƒãƒƒãƒå‡¦ç†: ${batchCount}å›ã®APIãƒªã‚¯ã‚¨ã‚¹ãƒˆã§è§£æï¼ˆ${BATCH_SIZE}å€‹ãšã¤å‡¦ç†ï¼‰</p>
            </div>
            <details class="border border-gray-200 rounded-lg">
                <summary class="cursor-pointer p-3 bg-gray-50 hover:bg-gray-100 font-medium text-gray-700">
                    ğŸ“‹ æŠ½å‡ºã•ã‚ŒãŸãƒ†ã‚­ã‚¹ãƒˆä¸€è¦§ã‚’è¡¨ç¤º (ã‚¯ãƒªãƒƒã‚¯ã—ã¦å±•é–‹)
                </summary>
                <div class="p-3 space-y-2 max-h-96 overflow-y-auto">
        `;
        
        shapes.forEach((shape, index) => {
            html += `
                <div class="border-l-2 border-blue-400 bg-gray-50 rounded p-2 text-sm">
                    <span class="inline-block bg-blue-500 text-white text-xs px-2 py-0.5 rounded mr-2">${index + 1}</span>
                    <span class="text-gray-600 text-xs">${shape.location}</span>
                    <p class="text-gray-800 mt-1 ml-8 text-xs">${escapeHtml(shape.text.substring(0, 100))}${shape.text.length > 100 ? '...' : ''}</p>
                </div>
            `;
        });
        
        html += `
                </div>
            </details>
        `;
        
        container.innerHTML = html;
        document.getElementById('resultsSection').classList.remove('hidden');
    }

    async function checkTextWithGemini(shapes) {
        if (!apiKey) {
            alert('APIã‚­ãƒ¼ãŒè¨­å®šã•ã‚Œã¦ã„ã¾ã›ã‚“');
            return;
        }
        
        const resultsContainer = document.getElementById('errorResults');
        resultsContainer.innerHTML = '<p class="text-gray-500">è§£æä¸­...</p>';
        
        try {
            const allErrors = [];
            
            // ãƒãƒƒãƒå‡¦ç†: BATCH_SIZEå€‹ãšã¤ã¾ã¨ã‚ã¦å‡¦ç†
            for (let i = 0; i < shapes.length; i += BATCH_SIZE) {
                const batch = shapes.slice(i, Math.min(i + BATCH_SIZE, shapes.length));
                const batchEnd = Math.min(i + BATCH_SIZE, shapes.length);
                const batchNumber = Math.floor(i / BATCH_SIZE) + 1;
                const totalBatches = Math.ceil(shapes.length / BATCH_SIZE);
                
                console.log(`Processing batch ${batchNumber}/${totalBatches}: ${i + 1}-${batchEnd} of ${shapes.length}`);
                updateLoadingMessage(`AIè§£æä¸­... (ãƒãƒƒãƒ ${batchNumber}/${totalBatches} - ${batchEnd}/${shapes.length}å€‹å‡¦ç†æ¸ˆã¿)`);
                
                // ãƒãƒƒãƒã‚’ã¾ã¨ã‚ã¦è§£æ
                const batchErrors = await analyzeBatchTexts(batch, i);
                
                // çµæœã‚’ãƒãƒ¼ã‚¸
                allErrors.push(...batchErrors);
                
                // ãƒ¬ãƒ¼ãƒˆåˆ¶é™å¯¾ç­–: æ¬¡ã®ãƒãƒƒãƒã¾ã§å°‘ã—å¾…æ©Ÿï¼ˆæœ€å¾Œã®ãƒãƒƒãƒä»¥å¤–ï¼‰
                if (i + BATCH_SIZE < shapes.length) {
                    const waitTime = 3000; // 3ç§’å¾…æ©Ÿï¼ˆ20 RPM = 3ç§’/ãƒªã‚¯ã‚¨ã‚¹ãƒˆï¼‰
                    console.log(`Waiting ${waitTime}ms before next batch...`);
                    await new Promise(resolve => setTimeout(resolve, waitTime));
                }
            }
            
            console.log(`Analysis complete. Total errors found: ${allErrors.length}`);
            displayErrorResults(allErrors);
            
        } catch (error) {
            console.error('Gemini API Error:', error);
            
            let errorMessage = error.message;
            let helpText = '';
            
            // Check for quota errors
            if (errorMessage.includes('quota') || errorMessage.includes('Quota exceeded')) {
                // Extract limit and wait time from error message
                const limitMatch = errorMessage.match(/limit:\s*(\d+)/);
                const waitMatch = errorMessage.match(/retry in ([\d.]+)s/);
                const currentLimit = limitMatch ? limitMatch[1] : '20';
                const waitSeconds = waitMatch ? Math.ceil(parseFloat(waitMatch[1])) : '10';
                
                helpText = `
                    <div class="mt-3 space-y-2">
                        <p class="font-semibold">ğŸ’¡ è§£æ±ºæ–¹æ³•:</p>
                        <ul class="list-disc list-inside space-y-1 text-sm">
                            <li><strong>ç„¡æ–™æ ã®ãƒ¬ãƒ¼ãƒˆåˆ¶é™:</strong> ${currentLimit}ãƒªã‚¯ã‚¨ã‚¹ãƒˆ/åˆ†</li>
                            <li><strong>ç¾åœ¨ã®è¨­å®š:</strong> ãƒãƒƒãƒå‡¦ç†ï¼ˆ${BATCH_SIZE}å€‹ãšã¤å‡¦ç†ï¼‰</li>
                            <li><strong>å¾…æ©Ÿæ™‚é–“:</strong> ç´„${waitSeconds}ç§’å¾Œã«è‡ªå‹•ãƒªãƒˆãƒ©ã‚¤ã—ã¾ã™</li>
                            <li><strong>å¯¾ç­–:</strong> ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆæ•°ãŒå¤šã„å ´åˆã€æ•°å›ã«åˆ†ã‘ã¦å‡¦ç†ã—ã¦ãã ã•ã„</li>
                            <li>ä½¿ç”¨çŠ¶æ³: <a href="https://ai.dev/rate-limit" target="_blank" class="underline text-blue-600">ã“ã¡ã‚‰ã§ç¢ºèª</a></li>
                            <li>ç„¡æ–™æ ã®è©³ç´°: <a href="https://ai.google.dev/gemini-api/docs/rate-limits" target="_blank" class="underline text-blue-600">ãƒ¬ãƒ¼ãƒˆåˆ¶é™ã«ã¤ã„ã¦</a></li>
                        </ul>
                        <div class="bg-yellow-100 border-l-4 border-yellow-500 p-3 mt-3">
                            <p class="text-yellow-800 text-sm">
                                <strong>ğŸ’¡ ãƒ’ãƒ³ãƒˆ:</strong> 
                                ${Math.ceil(shapes.length / BATCH_SIZE)}å€‹ã®ãƒãƒƒãƒã‚’å‡¦ç†ä¸­ã§ã™ã€‚
                                ç´„${Math.ceil((shapes.length / BATCH_SIZE) * 3)}ç§’ç¨‹åº¦ãŠå¾…ã¡ãã ã•ã„ã€‚
                            </p>
                        </div>
                    </div>
                `;
            } else if (errorMessage.includes('API key not valid')) {
                helpText = '<p class="text-sm mt-2">APIã‚­ãƒ¼ãŒæ­£ã—ã„ã‹ç¢ºèªã—ã¦ãã ã•ã„</p>';
            } else {
                helpText = '<p class="text-sm mt-2">APIã‚­ãƒ¼ãŒæ­£ã—ã„ã‹ã€ãƒãƒƒãƒˆãƒ¯ãƒ¼ã‚¯æ¥ç¶šã‚’ç¢ºèªã—ã¦ãã ã•ã„</p>';
            }
            
            resultsContainer.innerHTML = `
                <div class="bg-red-50 border border-red-200 rounded-lg p-4">
                    <p class="text-red-600 font-semibold">âŒ ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ</p>
                    <p class="text-red-700 mt-2 text-sm">${errorMessage}</p>
                    ${helpText}
                </div>
            `;
        }
    }

    // ãƒãƒƒãƒãƒ†ã‚­ã‚¹ãƒˆè§£æï¼ˆè¤‡æ•°ã®ãƒ†ã‚­ã‚¹ãƒˆã‚’1ãƒªã‚¯ã‚¨ã‚¹ãƒˆã§å‡¦ç†ï¼‰
    async function analyzeBatchTexts(batch, startIndex) {
        console.log(`Analyzing batch of ${batch.length} texts...`);
        
        // ãƒãƒƒãƒç”¨ã®ãƒ—ãƒ­ãƒ³ãƒ—ãƒˆã‚’æ§‹ç¯‰
        let batchPrompt = `ä»¥ä¸‹ã®è¤‡æ•°ã®ãƒ†ã‚­ã‚¹ãƒˆã‚’è§£æã—ã€èª¤å­—è„±å­—ãŒã‚ã‚Œã°æŒ‡æ‘˜ã—ã¦ãã ã•ã„ã€‚
IVRï¼ˆè‡ªå‹•éŸ³å£°å¿œç­”ã‚·ã‚¹ãƒ†ãƒ ï¼‰ã®è¨­å®šã‚·ãƒ¼ãƒˆã§ä½¿ç”¨ã•ã‚Œã‚‹ãƒ†ã‚­ã‚¹ãƒˆã§ã™ã€‚

`;

        // å„ãƒ†ã‚­ã‚¹ãƒˆã‚’ç•ªå·ä»˜ãã§è¿½åŠ 
        batch.forEach((shape, index) => {
            batchPrompt += `ã€ãƒ†ã‚­ã‚¹ãƒˆ${index + 1}ã€‘ï¼ˆ${shape.location}ï¼‰
"""
${shape.text}
"""

`;
        });

        batchPrompt += `ä»¥ä¸‹ã®å½¢å¼ã§JSONé…åˆ—ã¨ã—ã¦å›ç­”ã—ã¦ãã ã•ã„ï¼ˆå•é¡ŒãŒãªã‘ã‚Œã°ç©ºé…åˆ—ï¼‰:
[
  {
    "textIndex": 1,
    "error": "èª¤ã‚Šã®ã‚ã‚‹ãƒ†ã‚­ã‚¹ãƒˆéƒ¨åˆ†",
    "suggestion": "ä¿®æ­£æ¡ˆ",
    "reason": "æŒ‡æ‘˜ç†ç”±"
  },
  {
    "textIndex": 2,
    "error": "èª¤ã‚Šã®ã‚ã‚‹ãƒ†ã‚­ã‚¹ãƒˆéƒ¨åˆ†",
    "suggestion": "ä¿®æ­£æ¡ˆ",
    "reason": "æŒ‡æ‘˜ç†ç”±"
  }
]

æ³¨æ„äº‹é …:
- textIndexã¯ã€ãƒ†ã‚­ã‚¹ãƒˆç•ªå·ã€‘ã«å¯¾å¿œã•ã›ã¦ãã ã•ã„ï¼ˆ1ã‹ã‚‰é–‹å§‹ï¼‰
- èª¤å­—è„±å­—ã€ã‚¿ã‚¤ãƒ—ãƒŸã‚¹ã€æ˜ã‚‰ã‹ãªæ–‡æ³•ãƒŸã‚¹ã®ã¿ã‚’æŒ‡æ‘˜ã—ã¦ãã ã•ã„
- å°‚é–€ç”¨èªã‚„å›ºæœ‰åè©ã¯èª¤å­—ã¨ã—ã¦æŒ‡æ‘˜ã—ãªã„ã§ãã ã•ã„
- JSONå½¢å¼ä»¥å¤–ã®æ–‡ç« ã¯å‡ºåŠ›ã—ãªã„ã§ãã ã•ã„`;

        try {
            const response = await fetch('https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-lite:generateContent?key=' + apiKey, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    contents: [{
                        parts: [{
                            text: batchPrompt
                        }]
                    }],
                    generationConfig: {
                        temperature: 0.3,
                        maxOutputTokens: 2048,
                    }
                })
            });
            
            if (!response.ok) {
                const errorData = await response.json();
                throw new Error(errorData.error?.message || 'API request failed');
            }
            
            const data = await response.json();
            const resultText = data.candidates[0]?.content?.parts[0]?.text || '[]';
            
            console.log('Batch analysis result:', resultText.substring(0, 200) + '...');
            
            // JSONã‚’æŠ½å‡º
            const jsonMatch = resultText.match(/\[[\s\S]*\]/);
            if (!jsonMatch) {
                console.log('No errors found in batch');
                return [];
            }
            
            const errors = JSON.parse(jsonMatch[0]);
            
            // textIndexã”ã¨ã«ã‚°ãƒ«ãƒ¼ãƒ—åŒ–
            const groupedErrors = {};
            errors.forEach(error => {
                const idx = error.textIndex;
                if (!idx || idx < 1 || idx > batch.length) {
                    console.warn('Invalid textIndex:', idx, 'Skipping error:', error);
                    return;
                }
                
                if (!groupedErrors[idx]) {
                    groupedErrors[idx] = [];
                }
                
                groupedErrors[idx].push({
                    error: error.error,
                    suggestion: error.suggestion,
                    reason: error.reason
                });
            });
            
            // çµæœã‚’æ•´å½¢
            const result = [];
            batch.forEach((shape, index) => {
                const textIndex = index + 1;
                const shapeErrors = groupedErrors[textIndex] || [];
                
                if (shapeErrors.length > 0) {
                    console.log(`  Text ${textIndex}: ${shapeErrors.length} error(s) found`);
                    result.push({
                        shape: shape,
                        errors: shapeErrors,
                        index: startIndex + index + 1
                    });
                }
            });
            
            return result;
            
        } catch (error) {
            console.error('Batch analysis error:', error);
            throw error;
        }
    }

    async function analyzeTextForErrors(text, location, retryCount = 0) {
        const prompt = `ä»¥ä¸‹ã®ãƒ†ã‚­ã‚¹ãƒˆã‚’è§£æã—ã€èª¤å­—è„±å­—ãŒã‚ã‚Œã°æŒ‡æ‘˜ã—ã¦ãã ã•ã„ã€‚
IVRï¼ˆè‡ªå‹•éŸ³å£°å¿œç­”ã‚·ã‚¹ãƒ†ãƒ ï¼‰ã®è¨­å®šã‚·ãƒ¼ãƒˆã§ä½¿ç”¨ã•ã‚Œã‚‹ãƒ†ã‚­ã‚¹ãƒˆã§ã™ã€‚

ãƒ†ã‚­ã‚¹ãƒˆ:
"""
${text}
"""

ä»¥ä¸‹ã®å½¢å¼ã§JSONé…åˆ—ã¨ã—ã¦å›ç­”ã—ã¦ãã ã•ã„ï¼ˆå•é¡ŒãŒãªã‘ã‚Œã°ç©ºé…åˆ—ï¼‰:
[
  {
    "error": "èª¤ã‚Šã®ã‚ã‚‹ãƒ†ã‚­ã‚¹ãƒˆéƒ¨åˆ†",
    "suggestion": "ä¿®æ­£æ¡ˆ",
    "reason": "æŒ‡æ‘˜ç†ç”±"
  }
]

æ³¨æ„äº‹é …:
- èª¤å­—è„±å­—ã€ã‚¿ã‚¤ãƒ—ãƒŸã‚¹ã€æ˜ã‚‰ã‹ãªæ–‡æ³•ãƒŸã‚¹ã®ã¿ã‚’æŒ‡æ‘˜ã—ã¦ãã ã•ã„
- å°‚é–€ç”¨èªã‚„å›ºæœ‰åè©ã¯èª¤å­—ã¨ã—ã¦æŒ‡æ‘˜ã—ãªã„ã§ãã ã•ã„
- JSONå½¢å¼ä»¥å¤–ã®æ–‡ç« ã¯å‡ºåŠ›ã—ãªã„ã§ãã ã•ã„`;

        const response = await fetch('https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-lite:generateContent?key=' + apiKey, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                contents: [{
                    parts: [{
                        text: prompt
                    }]
                }],
                generationConfig: {
                    temperature: 0.3,
                    maxOutputTokens: 2048,
                }
            })
        });
        
        if (!response.ok) {
            const errorData = await response.json();
            const errorMessage = errorData.error?.message || 'API request failed';
            
            // Check if it's a quota error and we haven't retried too many times
            if (errorMessage.includes('Quota exceeded') && retryCount < 2) {
                // Extract wait time from error message
                const waitMatch = errorMessage.match(/retry in ([\d.]+)s/);
                const waitTime = waitMatch ? Math.ceil(parseFloat(waitMatch[1])) : 10;
                
                console.log(`Quota exceeded. Waiting ${waitTime} seconds before retry ${retryCount + 1}/2...`);
                updateLoadingMessage(`ãƒ¬ãƒ¼ãƒˆåˆ¶é™ã«ã‚ˆã‚Š${waitTime}ç§’å¾…æ©Ÿä¸­... (ãƒªãƒˆãƒ©ã‚¤ ${retryCount + 1}/2)`);
                
                await new Promise(resolve => setTimeout(resolve, (waitTime + 1) * 1000));
                
                // Retry the request
                return analyzeTextForErrors(text, location, retryCount + 1);
            }
            
            throw new Error(errorMessage);
        }
        
        const data = await response.json();
        const resultText = data.candidates[0]?.content?.parts[0]?.text || '[]';
        
        const jsonMatch = resultText.match(/\[[\s\S]*\]/);
        if (jsonMatch) {
            return JSON.parse(jsonMatch[0]);
        }
        
        return [];
    }

    function displayErrorResults(allErrors) {
        const container = document.getElementById('errorResults');
        
        if (allErrors.length === 0) {
            container.innerHTML = `
                <div class="bg-green-50 border border-green-200 rounded-lg p-6 text-center">
                    <svg class="mx-auto h-12 w-12 text-green-500" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"/>
                    </svg>
                    <p class="text-green-700 font-semibold mt-3">èª¤å­—è„±å­—ã¯è¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸ</p>
                    <p class="text-green-600 text-sm mt-1">ã™ã¹ã¦ã®ãƒ†ã‚­ã‚¹ãƒˆã¯æ­£å¸¸ã§ã™</p>
                </div>
            `;
            return;
        }
        
        let html = `
            <div class="bg-yellow-50 border border-yellow-200 rounded-lg p-4 mb-6">
                <p class="text-yellow-800 font-semibold">âš ï¸ ${allErrors.length}ä»¶ã®æŒ‡æ‘˜ãŒã‚ã‚Šã¾ã™</p>
            </div>
            <div class="space-y-6">
        `;
        
        allErrors.forEach(item => {
            // ä¿®æ­£æ¸ˆã¿ãƒ†ã‚­ã‚¹ãƒˆã‚’ç”Ÿæˆ
            let correctedText = item.shape.text;
            item.errors.forEach(error => {
                // æ­£è¦è¡¨ç¾ã§ã‚¨ãƒ©ãƒ¼éƒ¨åˆ†ã‚’ç½®æ›ï¼ˆå¤§æ–‡å­—å°æ–‡å­—ã‚’åŒºåˆ¥ã—ãªã„ï¼‰
                const regex = new RegExp(escapeRegExp(error.error), 'gi');
                correctedText = correctedText.replace(regex, error.suggestion);
            });
            
            html += `
                <div class="border-l-4 border-red-500 bg-white rounded-lg shadow-sm p-6">
                    <div class="flex items-start gap-3 mb-4">
                        <div class="flex-shrink-0 w-8 h-8 bg-red-500 text-white rounded-full flex items-center justify-center font-semibold">
                            ${item.index}
                        </div>
                        <div class="flex-1">
                            <h3 class="font-semibold text-gray-800 mb-1">${item.shape.location}</h3>
                            <div class="bg-gray-50 p-3 rounded border border-gray-200">
                                <p class="text-xs text-gray-500 mb-1">å…ƒã®æ–‡ç« :</p>
                                <p class="text-sm text-gray-800 mb-3">${escapeHtml(item.shape.text)}</p>
                                
                                <div class="border-t border-gray-300 pt-3 mt-3">
                                    <div class="flex items-start justify-between gap-2">
                                        <div class="flex-1">
                                            <p class="text-xs text-green-600 font-semibold mb-1">âœ… ä¿®æ­£å¾Œã®æ–‡ç« :</p>
                                            <p class="text-sm text-gray-900 font-medium" id="corrected-${item.index}">${escapeHtml(correctedText)}</p>
                                        </div>
                                        <button 
                                            onclick="copyToClipboard('corrected-${item.index}', this)"
                                            class="flex-shrink-0 bg-blue-500 hover:bg-blue-600 text-white px-3 py-1.5 rounded text-xs font-medium transition flex items-center gap-1"
                                            title="ä¿®æ­£å¾Œã®æ–‡ç« ã‚’ã‚³ãƒ”ãƒ¼"
                                        >
                                            ğŸ“‹ ã‚³ãƒ”ãƒ¼
                                        </button>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="space-y-3 ml-11">
            `;
            
            item.errors.forEach((error, errorIndex) => {
                html += `
                    <div class="bg-red-50 border border-red-200 rounded-lg p-4">
                        <div class="flex gap-2 mb-2">
                            <span class="inline-block bg-red-500 text-white text-xs px-2 py-1 rounded">æŒ‡æ‘˜ ${errorIndex + 1}</span>
                        </div>
                        <div class="space-y-2">
                            <div>
                                <p class="text-xs text-gray-600 mb-1">âŒ èª¤ã‚Š:</p>
                                <p class="text-red-700 font-medium">${escapeHtml(error.error)}</p>
                            </div>
                            <div>
                                <p class="text-xs text-gray-600 mb-1">âœ… ä¿®æ­£æ¡ˆ:</p>
                                <p class="text-green-700 font-medium">${escapeHtml(error.suggestion)}</p>
                            </div>
                            <div>
                                <p class="text-xs text-gray-600 mb-1">ğŸ’¡ ç†ç”±:</p>
                                <p class="text-gray-700">${escapeHtml(error.reason)}</p>
                            </div>
                        </div>
                    </div>
                `;
            });
            
            html += `
                    </div>
                </div>
            `;
        });
        
        html += '</div>';
        container.innerHTML = html;
    }

    function showLoading(message) {
        document.getElementById('loadingMessage').textContent = message;
        document.getElementById('loadingSection').classList.remove('hidden');
        document.getElementById('resultsSection').classList.add('hidden');
    }

    function hideLoading() {
        document.getElementById('loadingSection').classList.add('hidden');
    }

    function updateLoadingMessage(message) {
        document.getElementById('loadingMessage').textContent = message;
    }

    function escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }
    
    // ã‚³ãƒ”ãƒ¼æ©Ÿèƒ½
    function copyToClipboard(elementId, buttonElement) {
        const element = document.getElementById(elementId);
        const text = element.textContent;
        
        // ã‚¯ãƒªãƒƒãƒ—ãƒœãƒ¼ãƒ‰ã«ã‚³ãƒ”ãƒ¼
        navigator.clipboard.writeText(text).then(() => {
            // ãƒœã‚¿ãƒ³ã®è¡¨ç¤ºã‚’ä¸€æ™‚çš„ã«å¤‰æ›´
            const originalHTML = buttonElement.innerHTML;
            buttonElement.innerHTML = 'âœ… ã‚³ãƒ”ãƒ¼å®Œäº†';
            buttonElement.classList.add('bg-green-500');
            buttonElement.classList.remove('bg-blue-500', 'hover:bg-blue-600');
            
            // 2ç§’å¾Œã«å…ƒã«æˆ»ã™
            setTimeout(() => {
                buttonElement.innerHTML = originalHTML;
                buttonElement.classList.remove('bg-green-500');
                buttonElement.classList.add('bg-blue-500', 'hover:bg-blue-600');
            }, 2000);
        }).catch(err => {
            console.error('ã‚³ãƒ”ãƒ¼ã«å¤±æ•—ã—ã¾ã—ãŸ:', err);
            alert('ã‚³ãƒ”ãƒ¼ã«å¤±æ•—ã—ã¾ã—ãŸã€‚æ‰‹å‹•ã§ã‚³ãƒ”ãƒ¼ã—ã¦ãã ã•ã„ã€‚');
        });
    }
    
    // æ­£è¦è¡¨ç¾ç”¨ã®ã‚¨ã‚¹ã‚±ãƒ¼ãƒ—é–¢æ•°
    function escapeRegExp(string) {
        return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    }
    
    // ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°é–¢æ•°
    function shouldIncludeShape(sheetName, text) {
        // é™¤å¤–ã‚·ãƒ¼ãƒˆãƒã‚§ãƒƒã‚¯
        if (EXCLUDED_SHEETS.includes(sheetName)) {
            console.log(`  â­ï¸ Skipping sheet: ${sheetName}`);
            return false;
        }
        
        // é™¤å¤–ãƒ†ã‚­ã‚¹ãƒˆãƒ‘ã‚¿ãƒ¼ãƒ³ãƒã‚§ãƒƒã‚¯
        for (const pattern of EXCLUDED_TEXT_PATTERNS) {
            if (text.includes(pattern)) {
                console.log(`  â­ï¸ Skipping text containing: ${pattern}`);
                return false;
            }
        }
        
        return true;
    }
    </script>
</body>
</html>
